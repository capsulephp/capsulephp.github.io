[{"id":"\/3.x\/overview.html#1-1","title":"1.1. Overview","content":"Capsule is a PSR-11 (2.0) compliant autowiring dependency injection container with object-oriented configuration of constructor arguments and initialization methods, along with lazy resolution of arguments from various sources. Intended primarily for object entries, Capsule makes allowance for storing value entries as well.Given a hypothetical DataSource class ...class DataSource { public function __construct(PDO $pdo) { $this-&gt;pdo = $pdo; } \/* ... methods using $this-&gt;pdo ... *\/ } ... the following Capsule Container provides a shared instance of that DataSource using a shared instance of PDO:use Capsule\\Di\\Container; use Capsule\\Di\\Definitions; $def = new Definitions(); $def-&gt;{PDO::CLASS} -&gt;arguments([ $def-&gt;env('PDO_DSN'), $def-&gt;env('PDO_USERNAME'), $def-&gt;env('PDO_PASSWORD') ]); $container = new Container($def); $dataSource = $container-&gt;get(DataSource::CLASS); Capsule reflects on the DataSource class and sees that it needs a PDO instance. In turn, Capsule examines the PDO class definition, and creates a PDO instance using the PDO_* environment variables. Having done so, Capsule then uses that PDO instance to create the DataSource, and returns it.Although Capsule can inject object arguments implicitly based on the parameter type, it will not do so for scalar, array, resource, etc. types, nor will it do so for union typed parameters. Arguments for those types of parameters must be explicitly specified in the definition."},{"id":"\/3.x\/container.html#1-2","title":"1.2. Container Usage","content":" Note: If you use PHPStorm, you can copy the resources\/phpstorm.meta.php file to your project root as .phpstorm.meta.php for autocompletion on get() and new() method calls. After instantiating a Container ...use Capsule\\Di\\Container; use Capsule\\Di\\Definitions; $def = new Definitions(); $container = new Container($def); ... use its methods to retrieve identified objects and values."},{"id":"\/3.x\/container.html#1-2-1","title":"1.2.1. Retrieving Shared Instances","content":"get(string $id) : mixedReturns a shared instance of the defined class. Multiple calls to get() return the same object.$foo1 = $container-&gt;get(Foo::CLASS); $foo2 = $container-&gt;get(Foo::CLASS); var_dump($foo1 === $foo2); \/\/ bool(true) "},{"id":"\/3.x\/container.html#1-2-2","title":"1.2.2. Retrieving New Instances","content":"new(string $id) : mixedReturns a new instance of the defined class. Multiple calls to new() return different new object instances.$foo1 = $container-&gt;new(Foo::CLASS); $foo2 = $container-&gt;new(Foo::CLASS); var_dump($foo1 === $foo2); \/\/ bool(false) "},{"id":"\/3.x\/container.html#1-2-3","title":"1.2.3. Retrieving Values","content":"You can use get() to retrieve defined primitive values.$host = $container-&gt;get('db.host'); If a primitive value defined as a Lazy, multiple calls to get() will return the same value. However, multiple calls to new() may return different values, as the Lazy will be re-evaluated on each call."},{"id":"\/3.x\/container.html#1-2-4","title":"1.2.4. Checking For Existence","content":"has(string $id) : boolReturns true if the Container can successfully get() or new() the $id; otherwise, false.$container-&gt;has(stdClass::CLASS); \/\/ true $container-&gt;has('NoSuchClass'); \/\/ false "},{"id":"\/3.x\/container.html#1-2-5","title":"1.2.5. Callable Factories","content":"callableGet(string $id) : callablecallableNew(string $id) : callableThese return a call to get() or new() wrapped in a closure. Useful for providing factories to other containers.$callableGet = $container-&gt;callableGet(Foo::CLASS); $foo1 = $callableGet(); $foo2 = $callableGet(); var_dump($foo1 === $foo2); \/\/ bool(true) $callableNew = $container-&gt;callableNew(Foo::CLASS); $foo1 = $callableNew(); $foo2 = $callableNew(); var_dump($foo1 === $foo2); \/\/ bool(false) "},{"id":"\/3.x\/definitions\/overview.html#1-3-1","title":"1.3.1. Overview","content":"The Container will create and retain objects automatically. However, some objects may need arguments that cannot be provided automatically, or that need to be lazy-resolved. Likewise, you may wish to override object creation with your own factory logic. You can set these using Definitions.use Capsule\\Di\\Definitions; $def = new Definitions(); Specify each definition by a unique ID string; this string will act as a public property name on the Definitions object. You are not restricted to typical PHP property names; you can use any string, as long as it is enclosed in braces and quotes, like so:$def-&gt;typicalPropertyName = ...; $def-&gt;{'unusual.property-name'} = ...; You can specify a class definition or an interface definition by addressing it as a property on the Definitions class. Doing so will create the definition if it does not already exist, and will reuse any previously existing definition.\/\/ a class definition $def-&gt;{Foo::CLASS}-&gt;...; \/\/ an interface definition $def-&gt;{FooInterface::CLASS}-&gt;...; You can define a primitive value the same way.$def-&gt;{'db.host'} = '127.0.0.1'; You can define a \"named service\" or \"named instance\" of a class using the newDefinition() method; each new definition will be separate from every other definition of that class.$def-&gt;fooService = $def-&gt;newDefinition(Foo::CLASS)-&gt;...; You can define an alias to another definition like so:\/\/ {'foo.alias'} and {Foo::CLASS} will refer to \/\/ the exact same definition; changing one will \/\/ change the other $def-&gt;{'foo.alias'} = $def-&gt;{Foo::CLASS}; Finally, you can check isset() on the Definitions properties and unset () them if you like:if (isset($def-&gt;{Foo::CLASS})) { unset($def-&gt;{Foo::CLASS}); } "},{"id":"\/3.x\/definitions\/classes.html#1-3-2","title":"1.3.2. Class Definitions","content":"Define the initial and\/or extended construction logic for classes.All of the ClassDefinition methods are fluent, and can be called in any order."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-1-1","title":"1.3.2.1.1.1. By Position or Name","content":"Given this class ...class Foo { public function __construct( protected string $param0, protected string $param1 ) { } } ... you can set the constructor arguments all at once using arguments(), overriding all previous arguments:$def-&gt;{Foo::CLASS} -&gt;arguments([ 0 =&gt; 'arg0', 1 =&gt; 'arg1', ]); Alternatively, you can set them one at a time (or overriding an individual argument) using argument():$def-&gt;{Foo::CLASS} -&gt;argument(0, 'arg0') -&gt;argument(1, 'arg1'); You can specify arguments by position or name in any combination you like. Given the above class, specifying the arguments by name would look like this:$def-&gt;{Foo::CLASS} -&gt;arguments([ 'param1' =&gt; 'arg1', 'param0' =&gt; 'arg0', ]); Among named and positional arguments referring to the same parameter, a later argument replaces an earlier one. For example:$def-&gt;{Foo::CLASS} -&gt;argument(0, 'positional'); \/\/ $param0 is now 'positional' -&gt;argument('param0', 'named'); \/\/ $param0 is now 'named' -&gt;argument(0, 'positional again'); \/\/ $param0 is now 'positional again' "},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-1-2","title":"1.3.2.1.1.2. By Typehint","content":"You can also specify arguments by typehint. Given a class like this ...class Bar { public function __construct( protected stdClass $param0, protected string $param1 } { } } ... you might specify the the arguments like so:$def-&gt;{Bar::CLASS} -&gt;arguments([ 'param1' =&gt; 'arg1', stdClass::CLASS =&gt; new stdClass(), ]); Specifying arguments by typehint is best combined with Lazy resolution, described elsewhere.Arguments specified by name or position take precedence over arguments specified by typehint."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-1-3","title":"1.3.2.1.1.3. Variadic Arguments","content":"If a class has a variadic constructor argument ...class Baz { protected array $items; public function __construct( string ...$items } { $this-&gt;items = $items; } } ... it must be set using an array, like so:$def-&gt;{Baz::CLASS} -&gt;argument('items', ['a', 'b', 'c']); "},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-1-4","title":"1.3.2.1.1.4. Inherited Arguments","content":"By default, the Definition for a class will \"inherit\" the defined arguments of its parent classes. Inheritance of arguments works all the way up to the highest parent.For example, given these classes ...class Foo { public function __construct(string $arg0) { } } class Bar extends Foo { } ... and this Definition ...$def-&gt;{Foo::CLASS} -&gt;argument(0, 'value1') ... then the value of Bar $arg0 will be inherited from Foo $arg0 (in this case, it will be 'value1').You can override any or all inherited values by using argument() or arguments() on the Definition for the child class.If you want to disable or interrupt inheritance, call inherit(null) on the child Definition:$def-&gt;{Foo::CLASS} -&gt;argument(0, 'value1') $def-&gt;{Bar::CLASS} -&gt;inherit(null); "},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-1-5","title":"1.3.2.1.1.5. Argument Examination and References","content":"You can see if an argument value has been defined using hasArgument(), and retrieve the value of the argument using getArgument().if (! $def-&gt;{Foo::CLASS}-&gt;hasArgument('bar')) { $def-&gt;{Foo::CLASS}-&gt;argument('bar', 'barval'); } assert($def-&gt;{Foo::CLASS}-&gt;get('bar') === 'barval'); You can also get a reference to the argument value using refArgument(), so you can modify that value in place without having to get it and re-set it.$def-&gt;{Foo::CLASS}-&gt;argument('bar', 'barval'); \/\/ ... $bar =&amp; $def-&gt;{Foo::CLASS}-&gt;refArgument('bar'); $bar .= 'suffixed'; assert($def-&gt;{Foo::CLASS}-&gt;get('bar') === 'barvalsuffixed'); "},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-2","title":"1.3.2.1.2. Class Overrides","content":"If you like, you can specify an alternative class to use for instantiation instead of the using the definition ID as the class name. This means you can use a class that is different from the typehint ...$def-&gt;{AbstractFoo::CLASS} -&gt;class(Foo::CLASS) ... in which case you should be careful that the replacement class will actually work for the typehint.Setting an alternative class() will cause the Container to use the definition for that other class. In the above example, that means any AbstractFoo extended construction logic will be ignored in favor of the Foo object definition, although the Foo definition will still inherit any defined AbstractFoo arguments."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-1-3","title":"1.3.2.1.3. Factory Instantiation","content":"Instead of relying on automatic instantiation via arguments() and class(), you can set callable factory on the class definition. This lets you create the object yourself, instead of letting the Container instantiate it for you.The factory() takes precedence over the arguments() and class() settings.The callable factory must have the following signature ...function (Container $container) : object ... although the return typehint may be more specific if you like.For example:$def-&gt;{Foo::CLASS} -&gt;factory(function (Container $container) : Foo { return new Foo(); \/\/ or perform any other complex creation logic }); The factory() may be Lazy:$def-&gt;{Foo::CLASS} -&gt;factory( $def-&gt;newCall(FooFactory::CLASS, 'newInstance') ); It can also be used to return a class that is entirely different from the typehint ...$def-&gt;{Foo::CLASS} -&gt;factory(function (Container $container) : Bar { return new Bar(); }); ... in which case you must be careful that the replacement class will work for the typehint."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-2","title":"1.3.2.2. Extended Construction","content":"These \"extender\" methods will be applied to the object after initial construction (even if that construction was by factory()). You can specify them as many times as you like, and they will be applied in that order."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-2-1","title":"1.3.2.2.1. Property Injection","content":"To set any publicly-accessible property after construction, call the property() method with a property name and value:$def-&gt;{Foo::CLASS} -&gt;property('propertyName', 'propValue'); The value may be Lazy resolvable."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-2-2","title":"1.3.2.2.2. Setter Injection","content":"Each call to method() indicates a method to call on the object after it is instantiated. The typical case is for setter injection, but it can be used for any post-construction initializer logic using class methods.Given this class ...class Foo { protected $string; public function wrap(string $prefix, string $suffix) : void { $this-&gt;string = $prefix . $this-&gt;string . $suffix; } } ... you might direct these method() calls to occur after instantiation:$def-&gt;{Foo::CLASS} -&gt;method('wrap', 'foo', 'bar') -&gt;method('wrap', 'baz', 'dib'); Pass the method name as the first argument; the remaining arguments will be passed to that method call. These arguments may be Lazy."},{"id":"\/3.x\/definitions\/classes.html#1-3-2-2-3","title":"1.3.2.2.3. General Modification","content":"Sometimes method() calls will not be enough; you may need more complex modification logic. In these cases, add a modify() call to the definition. The typical use is for modifying the obejct itself, but it can be used for any other kind of initializer logic.Pass a callable with this signature ...function (Container $container, object $object) : void ... although the object typehint may be more specific if you like.For example:$def-&gt;{ComplexSetup::CLASS} -&gt;modify(function (Container $container, ComplexSetup $object) : void { \/\/ complicated setup logic, then $object-&gt;finalize(); }); "},{"id":"\/3.x\/definitions\/classes.html#1-3-2-2-4","title":"1.3.2.2.4. Decorators","content":"Whereas method(), modify(), and property() work on the object in place, the decorate() method allows you to return a completely different object if you like. To use it, pass a callable with following signature ...function (Container $container, object $object) : object ... although the object typehints may be more specific if you like. Be sure to return the new object at the end of the callable.For example:$def-&gt;{Foo::CLASS} -&gt;decorate(function (Container $container, Foo $foo) : DecoratedFoo { return new DecoratedFoo($foo); }); "},{"id":"\/3.x\/definitions\/interfaces.html#1-3-3-1","title":"1.3.3.1. Implementation Class","content":"You can indicate the implementation class to use for an interface typehint with the class() method:$def-&gt;{FooInterface::CLASS} -&gt;class(Foo::CLASS); Setting the class() will cause the Container to use the definition for that other class. In the above example, that means the Foo initial and extended construction logic will be used for each FooInterface typehint."},{"id":"\/3.x\/definitions\/interfaces.html#1-3-3-2","title":"1.3.3.2. Factory Callable","content":"Instead of indicating an implemention, you can set a callable factory for the interface definition. This lets you create the implementation object yourself, instead of letting the Container instantiate it for you.The callable factory must have the following signature ...function (Container $container) : object ... although the object typehint may be more specific if you like.For example:$def-&gt;{FooInterface::CLASS} -&gt;factory(function (Container $container) : Foo { return new Foo(); \/\/ or perform any other complex creation logic }); "},{"id":"\/3.x\/definitions\/values.html#1-3-4","title":"1.3.4. Primitive Values","content":"You can also define primitive values, such as nulls, booleans, integers, floats, strings, arrays, or resources:$def-&gt;foo = 'bar'; $def-&gt;{'db.host'} = '127.0.0.1'; Because each definition is retained as a public property on Definitions, you can overwrite or modify primitive value definitions in place. For example:$def-&gt;{'template.helpers'} = []; $def-&gt;{'template.helpers'}[] = 'anchor'; $def-&gt;{'template.helpers'}[] = 'escape'; $def-&gt;{'template.helpers'}[] = 'input'; \/\/ etc "},{"id":"\/3.x\/definitions\/values.html#1-3-4-1","title":"1.3.4.1. Lazy Resolution","content":"Primitive value definitions may also be Lazy (described elsewhere). For example:$def-&gt;{'db.dsn'} = $def-&gt;env('DB_DSN'); $def-&gt;{'db.user'} = $def-&gt;env('DB_USER'); $def-&gt;{'db.pass'} = $def-&gt;env('DB_PASS'); You might then Lazy-get() these values from the Container, like so:$def-&gt;{DB::CLASS} -&gt;arguments([ 'dsn' =&gt; $def-&gt;get('db.dsn'), 'user' =&gt; $def-&gt;get('db.user'), 'pass' =&gt; $def-&gt;get('db.pass'), ]); "},{"id":"\/3.x\/definitions\/values.html#1-3-4-2","title":"1.3.4.2. Naming Convention","content":"Remember that all values and objects in the Definitions share the same space for their IDs. To reduce naming conflicts among different libraries and packages, you may wish to adopt a value naming convention based on where those values will be used.For example, given a foobar\/database package with this class ...namespace Foobar\\Database; class Connection { public function __construct( protected string $dsn, protected string $username, protected string $password ) { } } ... the relevant value definitions may be named for the vendor and package ...$def-&gt;{'foobar\/database:dsn'} = $def-&gt;env('DB_DSN'); $def-&gt;{'foobar\/database:username'} = $def-&gt;env('DB_USER'); $def-&gt;{'foobar\/database:password'} = $def-&gt;env('DB_PASS'); $def-&gt;{Foobar\\Database\\Connection::CLASS} -&gt;arguments([ $def-&gt;get('foobar\/database:dsn'), $def-&gt;get('foobar\/database:username'), $def-&gt;get('foobar\/database:password'), ]); ... or they may be named for class constructor parameters ...$def-&gt;{'Foobar\\Database\\Connection:dsn'} = $def-&gt;env('DB_DSN'); $def-&gt;{'Foobar\\Database\\Connection:username'} = $def-&gt;env('DB_USER'); $def-&gt;{'Foobar\\Database\\Connection:password'} = $def-&gt;env('DB_PASS'); $def-&gt;{Foobar\\Database\\Connection::CLASS} -&gt;arguments([ $def-&gt;get('Foobar\\Database\\Connection:dsn'), $def-&gt;get('Foobar\\Database\\Connection:username'), $def-&gt;get('Foobar\\Database\\Connection:password'), ]); ... or you may come up with your own convention (or no convention at all)."},{"id":"\/3.x\/lazy.html#1-4","title":"1.4. Lazy Resolution","content":"Usually, you will not want arguments or values resolved at the time you specify them. For example, you may want a specify a new object instance as a constructor argument, but of course you don't want to instantiate that object at the moment of configuration. Instead, you probably want to instantiate it only at the moment of construction.The Definitions class provides methods to allow for late resolution of arguments via Lazy instances. These Lazy arguments are resolved only as the Container reads from the Definitions."},{"id":"\/3.x\/lazy.html#1-4-1","title":"1.4.1. Environment Variables","content":"env(string $varname[, string $vartype = null]) : Lazy\\EnvResolves to the value of the $varname environment variable.$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;env('BAR') \/\/ getenv('BAR') ); You may optionally specify a type to cast the value to:$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;env('BAR', 'int') \/\/ (int) getenv('BAR') ); "},{"id":"\/3.x\/lazy.html#1-4-2","title":"1.4.2. Comma-Separated Environment Variables","content":"csEnv(string $varname[, string $vartype = null]) : Lazy\\CsEnvResolves to an array of comma-separated values from the $varname environment variable. This is useful when you have to read from a list of values via an environment string; for example:NOTIFY_EMAILS=\"foo@example.com,bar@example.net,baz@example.org\" $def-&gt;{Notifier::CLASS} -&gt;argument( 'addresses', $def-&gt;csEnv('NOTIFY_EMAILS') \/\/ str_getcsv(getenv('NOTIFY_EMAILS')) ); You may optionally specify a type to cast all of the values to:$def-&gt;{IdList::CLASS} -&gt;argument( 'ids', $def-&gt;csEnv('ID_LIST', 'int') ); "},{"id":"\/3.x\/lazy.html#1-4-3","title":"1.4.3. Any Callable","content":"call(callable $callable) : Lazy\\CallResolves to the result returned by a callable; the callable must have this signature ...function (Container $container) ... and may specify the return type.For example:$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;call( function (Container $container) { $bar = $container-&gt;new(Bar::CLASS); \/\/ do some work with $bar, then: return $bar-&gt;getValue(); } ) ); "},{"id":"\/3.x\/lazy.html#1-4-4","title":"1.4.4. Function Calls","content":"functionCall(string $function, ...$arguments) : Lazy\\FunctionCallResolves to the return of a function call.$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;functionCall('barfunc') \/\/ barfunc() ); Any or all of the $arguments themselves can be Lazy as well."},{"id":"\/3.x\/lazy.html#1-4-5","title":"1.4.5. Static Method Calls","content":"staticCall(string|Lazy $class, string $method, ...$arguments) : Lazy\\StaticCallResolves to the return of a static method call.$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;staticCall('Bar', 'func') \/\/ Bar::func() ); Any or all of the $arguments themselves can be Lazy as well."},{"id":"\/3.x\/lazy.html#1-4-6","title":"1.4.6. Shared Instances From The Container","content":"get(string|Lazy $id) : Lazy\\GetResolves to an identified definition returned by Container::get().$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;get(Bar::CLASS) \/\/ $container-&gt;get(Bar::CLASS) ); "},{"id":"\/3.x\/lazy.html#1-4-7","title":"1.4.7. Shared Instance Method Calls","content":"getCall(string|Lazy $id, string $method, ...$arguments) : Lazy\\GetCallResolves to a method call on an object returned by Container::get().$def-&gt;{Foo::CLASS} -&gt;method( 'setBarVal', $def-&gt;getCall(Bar::CLASS, 'getValue') \/\/ $container-&gt;get(Bar::CLASS)-&gt;getValue() ); Any or all of the $arguments themselves can be Lazy as well."},{"id":"\/3.x\/lazy.html#1-4-8","title":"1.4.8. New Instances From The Container","content":"new(string|Lazy $id) : Lazy\\NewInstanceResolves to an identified definition returned by Container::new().$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;new(Bar::CLASS) \/\/ $container-&gt;new(Bar::CLASS) ); \/\/ --&gt; $container-&gt;new(Bar::CLASS) "},{"id":"\/3.x\/lazy.html#1-4-9","title":"1.4.9. New Instance Method Calls","content":"newCall(string|Lazy $id, string $method, ...$arguments) : Lazy\\NewCallResolves to a method call on an object returned by Container::new().$def-&gt;{Foo::CLASS} -&gt;method( 'setBarVal', $def-&gt;newCall(Bar::CLASS, 'getValue') \/\/ $container-&gt;new(Bar::CLASS)-&gt;getValue() ); Any or all of the $arguments themselves can be Lazy as well."},{"id":"\/3.x\/lazy.html#1-4-10","title":"1.4.10. Callable Factories","content":"callableGet(string|Lazy $id) : Lazy\\CallableGetcallableNew(string|Lazy $id) : Lazy\\CallableNewThese resolve to a closure around Container::get() or Container::new(). Useful for providing factories to other containers or locators.$def-&gt;{Foo::CLASS} -&gt;argument( 'bar', $def-&gt;callableGet(Bar::CLASS); ); \/\/ function () use ($container) { return $container-&gt;get(Bar::CLASS); } "},{"id":"\/3.x\/lazy.html#1-4-11","title":"1.4.11. Included Files","content":"include(string|Lazy $file) : Lazy\\IncludeFileResolves to the result returned by including a file; failure to find the file will not terminate execution.$def-&gt;{Foo::CLASS} -&gt;method( 'setBar', $def-&gt;include('bar.php') \/\/ include 'bar.php' ); "},{"id":"\/3.x\/lazy.html#1-4-12","title":"1.4.12. Required Files","content":"require(string|Lazy $file) : Lazy\\RequireFileResolves to the result returned by requiring a file; failure to find the file will terminate execution.$def-&gt;{Foo::CLASS} -&gt;method( 'setBar', $def-&gt;require('bar.php') \/\/ require 'bar.php' ); "},{"id":"\/3.x\/lazy.html#1-4-13","title":"1.4.13. Array Values","content":"array(array $values) : Lazy\\ArrayValuesResolves to an array, where each element has itself been lazy-resolved.Each element in the array will be inspected for Lazy resolution. This is a recursive inspection; if an array element is an array, that sub-array will also be lazy-resolved. You can mix Lazy and non-Lazy elements together in the array; the non-Lazy elements will be left as-is.$def-&gt;{Foo::CLASS} -&gt;argument('list', $def-&gt;array([ $def-&gt;env('BAR'), \/\/ getenv('BAR') 'BAZ', $def-&gt;env('DIB'), \/\/ getenv('DIB') ]) The ArrayValues object implements ArrayAccess, Countable, and IteratorAggregate, so in many cases you can work with it as if it is an array:$def-&gt;listing = $def-&gt;array([ 'bar' =&gt; $def-&gt;env('BAR') ]); $def-&gt;listing['baz'] = 'BAZ', $def-&gt;listing['dib'] = $def-&gt;env('DIB'); $count = count($def-&gt;listing); \/\/ 3 unset($def-&gt;listing['baz']); foreach ($def-&gt;listing as $key =&gt; $value) { \/\/ ... } Finally, to merge any iterable into an existing ArrayValues object, use its merge() method:$def-&gt;listing = $def-&gt;array([ 'foo', 'bar', 'baz' =&gt; 'dib', ]); $def-&gt;listing-&gt;merge([ 'zim', 'gir', 'irk' =&gt; 'doom', ]); \/* $def-&gt;listing will now resolve to ... [ 'foo', 'bar', 'baz' =&gt; 'dib', 'zim', 'gir', 'irk' =&gt; 'doom', ] *\/ The merge() method behaves just like array_merge()."},{"id":"\/3.x\/lazy.html#1-4-14","title":"1.4.14. Standalone Definitions","content":"Each definition itself is Lazy and will resolve to a new instance of the specified class as defined.$def-&gt;{Foo::CLASS} -&gt;argument( 'zim', $def-&gt;newDefinition(Zim::CLASS) \/\/ new Zim() ); Note that this is different from resolving via the Container as per new(). With a standalone definition, you can specify the arguments, modifiers, factory, etc. separately from whatever the \"default\" definition is in the Container."},{"id":"\/3.x\/providers.html#1-5","title":"1.5. Definition Providers","content":"You can create one or more Provider classes to work with a Definitions instance. To do so, implement the Provider interface ...use Capsule\\Di\\Definitions; use Capsule\\Di\\Provider; class PdoProvider implements Provider { public function provide(Definitions $def) : void { $def-&gt;{PDO::CLASS} -&gt;arguments([ $def-&gt;env('PDO_DSN'), $def-&gt;env('PDO_USERNAME'), $def-&gt;env('PDO_PASSWORD') ]); } } ... then pass an iterable of Provider instances to a new Container:$providers = [ new PdoProvider(), ]; $container = new Container( new Definitions(), $providers ); The $providers may be any iterable of Provider instances, not just an array.You can use Provider instances for definitions organized by: classes or class collections libraries or library collections packages or package collections HTTP or command line interfaces Development, test, or production environments It is up to you how you organize your Provider instances. For example, you may organize them by DDD and environment layers, like so:$providers = [ new DomainLayerProvider(), new ApplicatonLayerProvider(), new InfrastructureLayerProvider(), new HttpLayerProvider(), new ProductionEnvironmentProvider(), ]; You may wish to make your Provider instances mixable in various combinations, so you can reuse \"lower\" or \"inner\" definitions in concert with \"higher\" or \"outer\" definitions. For example, reusing some core definitions in a different environment:$providers = [ new DomainLayerProvider(), new ApplicatonLayerProvider(), new IntegrationTestingProvider(), ]; "},{"id":"\/3.x\/upgrading.html#1-6","title":"1.6. Upgrading","content":"Upgrading from 2.x to 3.x may be tedious but not difficult. The ContainerFactory has been removed in favor of direct instantiation of the Container. \/\/ 2.x $container = ContainerFactory::new($providers); \/\/ 3.x $container = new Container(new Definitions(), $providers); Definition entries are now accessed as Definitions properties via __get(), not via object() or value(). \/\/ 2.x $def-&gt;object(Foo::CLASS)-&gt;...; $def-&gt;value('foo', 'bar'); \/\/ 3.x $def-&gt;{Foo::CLASS}-&gt;...; $def-&gt;foo = 'bar'; Named instance\/object\/service definitions are likewise accessed as properties, and are instantiated via Definitions::newDefinition(). \/\/ 2.x $def-&gt;object('foo', Foo::CLASS)-&gt;...; \/\/ 3.x $def-&gt;foo = $def-&gt;newDefinition(Foo::CLASS)-&gt;...; Defining implementations for interfaces is explicit by calling the class() method. \/\/ 2.x $def-&gt;object(FooInterface::CLASS, Foo::CLASS)-&gt;...; \/\/ 3.x $def-&gt;{FooInterface::CLASS}-&gt;class(Foo::CLASS)-&gt;...; Interface definitions now have only the methods class() and factory(); previously, it was possible to set arguments() etc., but they were never honored. Named arguments no longer take precedence over positional ones; instead, they are \"equal\", with the last one set \"winning.\" class Foo { public function __construct(public string $bar) { } } \/\/ 2.x: $foo-&gt;bar will be 'named' $def-&gt;object(Foo::CLASS) -&gt;argument(0, 'positional') -&gt;argument('bar', 'named') -&gt;argument(0, 'positional'); \/\/ 3.x: $foo-&gt;bar will be 'positional again' $def-&gt;{Foo::CLASS} -&gt;argument(0, 'positional') -&gt;argument('bar', 'named') -&gt;argument(0, 'positional again'); 2.x used Lazy static methods for lazy resolution; 3.x Definitions now has factory methods for that. \/\/ 2.x 3.x Lazy::call() $def-&gt;call() \/\/ 2.x 3.x Lazy::env() $def-&gt;env() \/\/ 2.x 3.x Lazy::functionCall() $def-&gt;functionCall() \/\/ 2.x 3.x Lazy::get() $def-&gt;get() \/\/ 2.x 3.x Lazy::getCall() $def-&gt;getCall() \/\/ 2.x 3.x Lazy::include() $def-&gt;include() \/\/ 2.x 3.x Lazy::new() $def-&gt;new() \/\/ 2.x 3.x Lazy::newCall() $def-&gt;newCall() \/\/ 2.x 3.x Lazy::require() $def-&gt;require() Exceptions are now in the Capsule\\Di\\Exception namespace. "},{"id":"\/2.x.html#2","title":"2. Capsule 2.x","content":"A PSR-11 compliant autowiring dependency injection container with class-based configuration of constructor arguments and initialization methods, and lazy evaluation of arguments. Intended primarily for objects, the container also makes allowance for storing non-object values."},{"id":"\/2.x.html#2-1","title":"2.1. Example","content":"The following container provides a shared instance of a hypothetical data mapper using a shared instance of PDO.use Capsule\\Di\\Definitions; use Capsule\\Di\\Lazy; class DataMapper { public function __construct(PDO $pdo) { $this-&gt;pdo = $pdo; } } $def = new Definitions(); $def-&gt;object(PDO::CLASS) -&gt;arguments([ Lazy::env('PDO_DSN'), Lazy::env('PDO_USERNAME'), Lazy::env('PDO_PASSWORD') ]); $container = $def-&gt;newContainer(); $dataMapper = $container-&gt;get(DataMapper::CLASS); "},{"id":"\/2.x.html#2-2","title":"2.2. Container Methods","content":" N.b.: If you use PHPStorm, you can copy the resources\/phpstorm.meta.php file to your project root as .phpstorm.meta.php for autocompletion on get() and new() method calls. "},{"id":"\/2.x.html#2-2-1","title":"2.2.1. get(string $id) : mixed\n","content":"Returns a shared instance of the specified entry class, or the entry value. Multiple calls to get() return the same object instance.$foo1 = $container-&gt;get(Foo::CLASS); $foo2 = $container-&gt;get(Foo::CLASS); var_dump($foo1 === $foo2); \/\/ bool(true) "},{"id":"\/2.x.html#2-2-2","title":"2.2.2. has(string $id) : bool\n","content":"Returns true if the Container has an $id entry, or if the $id is an existing class; otherwise, false.$container-&gt;has(stdClass::CLASS); \/\/ true $container-&gt;has('NoSuchClass'); \/\/ false "},{"id":"\/2.x.html#2-2-3","title":"2.2.3. new(string $id) : mixed\n","content":"Returns a new instance of the specified entry class, or the entry value. Multiple calls to new() return different new object instances.$foo1 = $container-&gt;new(Foo::CLASS); $foo2 = $container-&gt;new(Foo::CLASS); var_dump($foo1 === $foo2); \/\/ bool(false) "},{"id":"\/2.x.html#2-2-4","title":"2.2.4. callableGet(string $id) : callable\n","content":"Returns a call to get() wrapped in a closure. Useful for providing factories to other containers.$callable = $container-&gt;callableGet(Foo::CLASS); $foo1 = $callable(); $foo2 = $callable(); var_dump($foo1 === $foo2); \/\/ bool(true) "},{"id":"\/2.x.html#2-2-5","title":"2.2.5. callableNew(string $id) : callable\n","content":"Returns a call to new() wrapped in a closure. Useful for providing factories to other containers.$callable = $container-&gt;callableNew(Foo::CLASS); $foo1 = $callable(); $foo2 = $callable(); var_dump($foo1 === $foo2); \/\/ bool(false) "},{"id":"\/2.x.html#2-3","title":"2.3. Object Definition Methods","content":"Whereas the Container will create and retain objects automatically, you may need to define some factories and arguments for their construction. You can do so via the Definitions object.When you are done with definitions, call newContainer() to get back a fully-configured Container object.$def = new Definitions(); \/\/ ... $container = $def-&gt;newContainer(); Specify the entry definition by $id; you may enter object or value definitions.\/\/ gets any existing definition, whether object or value. \/\/ \/\/ if the definition does not exist, it is created as via \/\/ $def-&gt;object(...) and returned. \/\/ \/\/ does not overwrite any previous entry. $def-&gt;object(Foo::CLASS)...; \/\/ define an object entry, identified by an arbitrary string. \/\/ replaces the previous entry identified by that string. $def-&gt;object('foo2', Foo::CLASS)-&gt;...; \/\/ define an object entry, identified by an arbitrary string; \/\/ in this case, to define the default implementation for an \/\/ interface. \/\/ \/\/ replaces the previous entry identified by that string. $def-&gt;object(FooInterface::CLASS, Foo::CLASS); \/\/ define a value entry, identified by an arbitrary string. \/\/ replaces the previous entry identified by that string. $def-&gt;value('val1', ...);  N.b.: Objects and values share the $id space. "},{"id":"\/2.x.html#2-3-1","title":"2.3.1. arguments(array $arguments) : Definition\n","content":"Sets all the arguments for the $id constructor parameters, replacing all previously-existing arguments for $id.Given this class:class Foo { public function __construct(string $param1, string $param2) { \/\/ ... } } ... you can set the constructor arguments by position like so:$def-&gt;object(Foo::CLASS) -&gt;arguments([ 'arg1', 'arg2' ]); Alternatively, you can set the constructor arguments by name:$def-&gt;object(Foo::CLASS) -&gt;arguments([ 'param1' =&gt; 'arg1', 'param2' =&gt; 'arg2' ]);  N.b.: Named arguments take precedence over positional ones. "},{"id":"\/2.x.html#2-3-2","title":"2.3.2. argument(int|string $parameter, mixed $argument) : Definition\n","content":"Sets one argument for a $id constructor parameter by position or name, replacing any previously-existing argument.$def-&gt;object(Foo::CLASS) -&gt;argument(0, 'arg1') -&gt;argument('param2', 'arg2');  N.b.: Named arguments take precedence over positional ones. "},{"id":"\/2.x.html#2-3-3","title":"2.3.3. factory(callable $callable) : Definition\n","content":"Use this to set a callable factory for a $id (instead of letting the Container to construct it for you). The callable factory must have the following signature ...function (Container $container) ... and may specify the return type.For example:$def-&gt;object(Foo::CLASS) -&gt;factory(function (Container $container) { return new Foo(); \/\/ or perform any other complex creation logic }); This can be useful for defining default implementations of interfaces as well:$def-&gt;object(BarInterface::CLASS) -&gt;factory(function (Container $container) : BarImplementation { return new BarImplementation(); }); "},{"id":"\/2.x.html#2-3-4","title":"2.3.4. method(string $method, ...$arguments) : Definition\n","content":"Specifies methods to call on the $id object after it is instantiated, whether by Container itself or by a factory. Use this for setter injection, or for other post-instantiation initializer logic.Given this class ...class Foo { protected $string; public function append(string $suffix) { $this-&gt;string .= $suffix; } } ... you might call these methods after instantiation:$def-&gt;object(Foo::CLASS) -&gt;method('append', 'bar') -&gt;method('append', 'baz'); "},{"id":"\/2.x.html#2-4","title":"2.4. Lazy Arguments","content":"Often you will not want to have your arguments evaluated at the time you specify them. For example, you may want a specify a new object instance as a constructor argument, but of course you don't want to instantiate that object at the moment of configuration; you want to instantiate it only at the moment of construction.The Lazy class allows for late evaluation of arguments; they are resolved only as the Container creates objects or calls methods on those objects. Use the Lazy static factory methods to create Lazy objects for a variety of purposes. N.b.: Lazy can be used both for constructor arguments and for method() call arguments. "},{"id":"\/2.x.html#2-4-1","title":"2.4.1. Lazy::call(callable $callable) : LazyInterface","content":"Resolves to the result returned by a callable; the callable must have this signature ...function (Container $container) ... and may specify the return type.For example:$def-&gt;object(Foo::class) -&gt;argument('bar', Lazy::call( function (Container $container) { $bar = $container-&gt;new(Bar::CLASS); \/\/ do some work with $bar, then: return $bar-&gt;getValue(); } ) ); "},{"id":"\/2.x.html#2-4-2","title":"2.4.2. Lazy::env(string $varname) : LazyInterface","content":"Resolves to the value of the $varname environment variable.$def-&gt;object(Foo::CLASS) -&gt;argument('bar', Lazy::env('BAR')); \/\/ --&gt; return getenv('BAR'); "},{"id":"\/2.x.html#2-4-3","title":"2.4.3. Lazy::functionCall(string $function, ...$arguments) : LazyInterface","content":"Resolves to the return of a function call.$def-&gt;object(Foo::class) -&gt;argument('bar', Lazy::functionCall('barfunc')); \/\/ --&gt; return barfunc();  N.b.: The $arguments themselves can be Lazy as well. "},{"id":"\/2.x.html#2-4-4","title":"2.4.4. Lazy::get(string $id) : LazyInterface","content":"Resolves to an object returned by Container get().$def-&gt;object(Foo::CLASS) -&gt;argument('bar', Lazy::get(Bar::CLASS)); \/\/ --&gt; return $container-&gt;get(Bar::CLASS); "},{"id":"\/2.x.html#2-4-5","title":"2.4.5. Lazy::getCall(string $id, string $method, ...$arguments) : LazyInterface","content":"Resolves to a method call on an object returned by Container get().$def-&gt;object(Foo::CLASS) -&gt;method('setBarVal', Lazy::getCall(Bar::CLASS, 'getValue')); \/\/ --&gt; return $container-&gt;get(Bar::CLASS)-&gt;getValue();  N.b.: The $arguments themselves can be Lazy as well. "},{"id":"\/2.x.html#2-4-6","title":"2.4.6. Lazy::include(string|LazyInterface $file) : LazyInterface","content":"Resolves to the result returned by including a file.$def-&gt;object(Foo::CLASS) -&gt;method('setBar', Lazy::include('bar.php')); \/\/ --&gt; return include 'bar.php'; "},{"id":"\/2.x.html#2-4-7","title":"2.4.7. Lazy::new(string $id) : LazyInterface","content":"Resolves to an object returned by Container new().$def-&gt;object(Foo::CLASS) -&gt;arguments([Lazy::new(Bar::CLASS)]); \/\/ --&gt; $container-&gt;new(Bar::CLASS) "},{"id":"\/2.x.html#2-4-8","title":"2.4.8. Lazy::newCall(string $id, string $method, ...$arguments) : LazyInterface","content":"Resolves to a method call on an object returned by Container new().$def-&gt;object(Foo::CLASS) -&gt;method('setBarVal', Lazy::newCall(Bar::CLASS, 'getValue')); \/\/ --&gt; $container-&gt;new(Bar::CLASS)-&gt;getValue();  N.b.: The $arguments themselves can be Lazy as well. "},{"id":"\/2.x.html#2-4-9","title":"2.4.9. Lazy::require(string|Lazy $file) : LazyInterface","content":"Resolves to the result returned by requiring a file.$def-&gt;object(Foo::CLASS) -&gt;method('setBar', Lazy::require('bar.php')); \/\/ --&gt; return require 'bar.php'; "},{"id":"\/2.x.html#2-4-10","title":"2.4.10. Lazy::staticCall(string $class, string $method, ...$arguments) : LazyInterface","content":"Resolves to the return of a static method call.$def-&gt;object(Foo::class) -&gt;argument('bar', Lazy::staticCall('Bar', 'func')); \/\/ --&gt; return Bar::func();  N.b.: The $arguments themselves can be Lazy as well. "},{"id":"\/2.x.html#2-5","title":"2.5. Value Definition Methods","content":"The Definitions object has one method to define value $id entries:\/\/ define the 'foo' $id entry as the string 'bar' $def-&gt;value('foo', 'bar'); This will replace any previously exising foo value, but will not replace a previously existing foo object; the call to value() will throw an exception in that case.Values can be any PHP value: scalar, array, resource, etc."},{"id":"\/2.x.html#2-6","title":"2.6. Definition Providers","content":"You can create a series of Provider classes to operate on a Definitions instance. This can help to keep definition sets separate from each other, so you can mix-and-match them on a contextual basis.To do so, implement the Provider interface ...use Capsule\\Di\\Definitions; use Capsule\\Di\\Lazy; use Capsule\\Di\\Provider; class PdoProvider implements Provider { public function provide(Definitions $def) : void { $def-&gt;object(PDO::CLASS) -&gt;arguments([ Lazy::env('PDO_DSN'), Lazy::env('PDO_USERNAME'), Lazy::env('PDO_PASSWORD') ]); } } ... then pass any number of Provider instances to ContainerFactory::new() method:$container = ContainerFactory::new([ new PdoProvider(), ]);  Note: ContainerFactory::new() will take any iterable, not just an array. You can use Provider instances to provide definitions for: classes or class collections libraries or library collections packages or package collections separate layers (Domain layer, Infrastructure layer, etc) HTTP environments, CLI environments, test environments, etc It is up to you how you organize your providers."},{"id":"\/1.x.html#3","title":"3. Capsule 1.x","content":"Most dependency injection containers work through public configuration, are intended for use at the application level, and use \"stringly\"-typed retrieval methods.Capsule, on the other hand, is intended for use at the library, module, component, or package level; has no public methods for configuration; and encourages typehinted retrieval methods.This means that you composer require capsule\/di ~1.0 into your package, extend the Container for your library or module, and __construct() your component objects inside that extended container. You then add typehinted public methods for object retrieval."},{"id":"\/1.x.html#3-1","title":"3.1. An Example","content":"The following container provides a shared instance of a hypothetical data mapper using a shared instance of PDO.&lt;?php class MyCapsule extends \\Capsule\\Di\\Container { public function __construct(array $env = []) { $this-&gt;setEnv($env); $this-&gt;provide(PDO::CLASS)-&gt;args( $this-&gt;env('DB_DSN'), $this-&gt;env('DB_USERNAME'), $this-&gt;env('DB_PASSWORD') ); $this-&gt;provide(MyDataMapper::CLASS)-&gt;args( $this-&gt;service(PDO::CLASS) ); } public function getMyDataMapper() : MyDataMapper { return $this-&gt;serviceInstance(MyDataMapper::CLASS); } } class MyDataMapper { public function __construct(PDO $pdo) { ... } } $capsule = new MyCapsule([ 'DB_DSN' =&gt; 'mysql:host=localhost;dbname=mydb', 'DB_USERNAME' =&gt; 'my_user', 'DB_PASSWORD' =&gt; 'my_pass', ]); $mapper = $capsule-&gt;getMyDataMapper(); \/\/ instanceof MyDataMapper "},{"id":"\/1.x.html#3-2","title":"3.2. Initialization Methods","content":"Call these methods within __construct() to configure the container. Note that they are all protected; they cannot be called from outside the container."},{"id":"\/1.x.html#3-2-1","title":"3.2.1. default(string $class) : Config\n","content":"Returns a Config object (see below) so you can set the default constructor arguments, post-instantiation method calls, and instantiation factory for a particular class. All object instantiations will use this configuration by default.&lt;?php public function __construct() { \/\/ ... $this-&gt;default(Foo::CLASS)-&gt;args( 'foo', 'bar', 'baz', ); } "},{"id":"\/1.x.html#3-2-2","title":"3.2.2. provide(string $id, LazyInterface $lazy = null) : ?LazyNew\n","content":"Use this to provide a shared instance of a class that will be reused after it is instantiated.By default, the provide() method presumes the service $id is a class name, and the shared instance is registered under that class name.The returned LazyNew object extends Config, so you can further configure the object prior to its instantiation, overriding the class defaults.&lt;?php public function __construct() { \/\/ ... \/\/ uses default arguments $this-&gt;provide(Foo::CLASS); \/\/ overrides default arguments $this-&gt;provide(Bar::CLASS)-&gt;args( 'zim', 'dib', 'gir', ); } Use this to provide a shared instance of a class that will be reused after it is instantiated. The shared instance is registered under the $id, which may be any class name or any other identifying string.If you pass a $lazy argument to provide(), the $lazy will be used to create the service instance, in which case the $id may or may not match the class of the lazy-loaded instance. When passing an explicit $lazy, provide() will return null."},{"id":"\/1.x.html#3-2-3","title":"3.2.3. service(string $id) : LazyService\n","content":"Use this to specify that a dependency should be a shared service instance registered using provide(). (The service instance may not be defined yet.)&lt;?php public function __construct() { \/\/ ... $this-&gt;default(Foo::CLASS)-&gt;args( $this-&gt;service(Bar::CLASS) ); } "},{"id":"\/1.x.html#3-2-4","title":"3.2.4. serviceCall(string $id, string $func, ...$args) : LazyCall\n","content":"Use this to specify that a dependency should be the result of a method call to a shared service instance.&lt;?php public function __construct() { \/\/ ... \/\/ provide a MapperLocator $this-&gt;provide(MapperLocator::CLASS); \/\/ for the Wiki application service, get the WikiMapper \/\/ out of the MapperLocator $this-&gt;default(WikiService::CLASS)-&gt;args( $this-&gt;serviceCall(MapperLocator::CLASS, 'get', WikiMapper::CLASS) ); } "},{"id":"\/1.x.html#3-2-5","title":"3.2.5. new(string $class) : LazyNew\n","content":"Use this to specify that a dependency should be a new instance of a class, not a shared instance.&lt;?php public function __construct() { \/\/ ... $this-&gt;default(Service::CLASS)-&gt;args( $this-&gt;new(SupportingObject::CLASS) ); } The returned LazyNew object extends Config, so you can further configure the object prior to its instantiation, overriding the class defaults."},{"id":"\/1.x.html#3-2-6","title":"3.2.6. call(callable $func, ...$args) : LazyCall\n","content":"Use this to specify that a dependency should be the results of invoking a callable, whether an instance method, static method, or function. (The PHP keywords include and require are also supported.)&lt;?php public function __construct() { \/\/ ... $this-&gt;default(Service::CLASS)-&gt;args( $this-&gt;call('include', '\/path\/to\/file.php') ); } "},{"id":"\/1.x.html#3-2-7","title":"3.2.7. closure(string $func, ...$args) : \\Closure\n","content":"This returns a Closure that makes a call to a Capsule container method. It is useful for providing new-instance and service-instance callables to other containers, locators, registries, and factories. It will not be invoked as a lazy-loaded dependency at instantiation time.&lt;?php public function __construct() { \/\/ ... \/\/ presuming the the MapperLocator takes an array of callable factories \/\/ as its first argument $this-&gt;default(MapperLocator::CLASS)-&gt;args( [ $this-&gt;closure('newInstance', ThreadMapper::CLASS), $this-&gt;closure('newInstance', AuthorMapper::CLASS), $this-&gt;closure('newInstance', ReplyMapper::CLASS), ] ); } "},{"id":"\/1.x.html#3-2-8","title":"3.2.8. env(string $key) : mixed\n","content":"Returns the value of the container-specific $env[$key] property (if set), then the value of getenv($id) (if not false), and then null.&lt;?php public function __construct(array $env = []) { $this-&gt;setEnv($env); \/\/ ... $this-&gt;provide(PDO::CLASS)-&gt;args( $this-&gt;env('DB_DSN'), $this-&gt;env('DB_USERNAME'), $this-&gt;env('DB_PASSWORD') ); } The above will use $env['DB_DSN'] (et al.) if they are passed to the constructor, and fall back to getenv('DB_DSN') if they are not.To set or replace all container-specific environment values, call setEnv(array $env).To merge new values with existing container-specific environment values, call addEnv(array $env)."},{"id":"\/1.x.html#3-2-9","title":"3.2.9. alias(string $from, string $to) : void\n","content":"Use this to alias a class $from its original name $to another name. All requests for $from will receive an instance of $to.This can be useful for specifying default implementations for interfaces.&lt;?php public function __construct() { $this-&gt;alias('FooInterface', 'FooImplementation'); $instance = $this-&gt;newInstance('FooInterface'); \/\/ instanceof FooImplementation } "},{"id":"\/1.x.html#3-3","title":"3.3. Kickoff Methods","content":"These methods return an actual instance of the requested class, thus invoking all the lazy-loading configurations for that class and its dependency.These are protected methods, and should be called from typehinted methods on your extended container class to provide objects from your library, package, module, or component."},{"id":"\/1.x.html#3-3-1","title":"3.3.1. newInstance(string $class, ...$args) : mixed\n","content":"This returns a new instance of the specified class, with additional arguments that override the default for that class. Multiple calls to newInstance() return different new instances.&lt;?php class MyCapsule extends \\Capsule\\Di\\Container { public function newPdo() : PDO { return $this-&gt;newInstance(PDO::CLASS); } } "},{"id":"\/1.x.html#3-3-2","title":"3.3.2. serviceInstance(string $id) : mixed\n","content":"This returns a shared service instance from the Capsule. Multiple calls to serviceInstance() return the same instance.&lt;?php class MyCapsule extends \\Capsule\\Di\\Container { public function getPdo() : PDO { return $this-&gt;serviceInstance(PDO::CLASS); } } "},{"id":"\/1.x.html#3-4","title":"3.4. Config Object Methods","content":"These fluent methods are available on the return of default(), new(), and provide(). They allow you to further configure the class specified by those methods."},{"id":"\/1.x.html#3-4-1","title":"3.4.1. args(...$args) : self\n","content":"Sets the constructor arguments for the class. These are sequential; lazy-loaded dependencies will be invoked when the object is actually created. Multiple calls to args() will reset and replace the previous constructor arguments.To reset the args, call resetArgs()."},{"id":"\/1.x.html#3-4-2","title":"3.4.2. call(string $func, ...$args) : self\n","content":"Adds one post-instantiation method call on the object. This is good for setter injection, and for post-instantiation setup methods. Multiple calls to call() will add to the previous calls.To reset the calls, use resetCalls()."},{"id":"\/1.x.html#3-4-3","title":"3.4.3. factory(callable $factory) : self\n","content":"Sets a custom factory callable to use for instantiating the object. This factory will be used in place of the Capsule factory. The $args values will be passed to the custom factory when it is called, and the $calls will be made on the object returned from the custom factory.To reset the factory so that Capsule factory is used, call resetFactory()."},{"id":"\/1.x.html#3-5","title":"3.5. Automated Configuration","content":"If you do not define the default() configuration for a class, the Capsule will reflect on the requested class instance and examine its constructor arguments. The Capsule will then populate each argument with: a shared service instance with a matching class name, if one has been provide()-ed; or, a new instance of that class Non-class typehints cannot be configured automatically."},{"id":"\/1.x.html#3-6","title":"3.6. Implementing PSR-11","content":"PSR-11 is a \"stringly\"-typed interface. The Capsule container does not implement it by default, but you can do so easily.&lt;?php class Psr11Capsule extends \\Capsule\\Di\\Container implements \\Psr\\Container\\ContainerInterface { public function get($id) { return $this-&gt;getRegistry()-&gt;get($id); } public function has($id) { return $this-&gt;getRegistry()-&gt;has($id); } } "},{"id":"\/1.x.html#3-7","title":"3.7. Serving From Other Containers","content":"TBD."},{"id":"\/1.x.html#3-8","title":"3.8. Providing To Other Containers","content":"TBD.Note that you can wrap it in a closure or other lazy-loader so that it does not get created until it is called."}]